# УРОК
# Модуль 1. Практика GIT. Базовые структуры данных
# Динамическая типизация
###################################################################################################
#В Python тип данных хранится не в переменной, а в самом объекте, на который она ссылается.
# Стоит упомянуть, что в Python объектом является все.

#Python не совсем воспринимает такое понятие как переменная.
# Чтобы полностью передать смысл, правильнее будет сказать,
# что это имя или же идентификатор, ссылающийся на объект

#Говоря о динамической типизации, мы подразумеваем, что тип данных внутри переменной может меняться.
#При переопределении переменной и ее ТИП ИЗМЕНЯЕТСЯ.
#####################################################################################################
#P.S.
#Переменная является частью памяти, в которую мы помещаем объект, чтобы использовать позже.
#В Python работать напрямую с адресами памяти не представляется возможным.
# Однако, есть одно исключение – функция id, которая в определенных реализациях может
# показать нам адрес памяти объекта. Тем не менее ее основная и, пожалуй, единственная цель,
# это ПРОВЕРИТЬ ссылаются ли два имени на один и тот же объект, т. к. ОБРАТИТЬСЯ по этому адресу
# средствами Python невозможно.
#####################################################################################################

variable_name = 'ORION'
print(variable_name, type(variable_name))  #выводим ТЕКУЩЕЕ значение и тип переменной variable_name

variable_name = 8
print(variable_name, type(variable_name))

variable_name = 8.4
print(variable_name, type(variable_name))

variable_name = True
print(variable_name, type(variable_name))

variable_name = 'ORION'
print(variable_name, type(variable_name))

variable_name = ['ORION', 2, 8.4, True]
print(variable_name, type(variable_name))

print(id(variable_name))

#В каждом из этих случаев мы видим, что одна и та же переменная «variable_name» ссылается
# на объекты разных типов.
#В процессе работы мы можем ИЗМЕНЯТЬ тип данных внутри переменной.

# Однако, нельзя забывать и о том, чтобы при определенных операциях, например при математическом сложении,
# оба объекта были одного типа. То есть, чтобы после смена типа данных при операциях не возникло КОНФЛИКТА.
# Как в случае, если мы сложим переменную «age», содержащую число 30.0 (тип float), и переменную «new_age»,
# содержащую строку «30» (тип str), и получим ошибку

#   age = 30.0
#   new_age = "30"
#   print(age + new_age)
# TypeError: unsupported operand type(s) for +: 'float' and 'str'

# Проверим на СОВПАДЕНИЕ адреса памяти (ОБЪЕКТОВ) переменных
var_adress1 = "qwerty"
var_adress2 = [1, 4, 17887]
print(id(variable_name) == id(var_adress1))
print(id(variable_name) != id(var_adress2))