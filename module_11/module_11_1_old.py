#Цель задания: Освоить механизмы создания процессов в Python.
"""Практически применить знания, создав несколько параллельных процессов и запустив их."""
'''Задание:
Моделирование программы для управления данными о движении товаров на складе и эффективной обработки запросов на 
обновление информации в многопользовательской среде.
Представим, что у вас есть система управления складом, где каждую минуту поступают запросы на обновление информации о 
поступлении товаров и отгрузке товаров.
Наша задача заключается в разработке программы, которая будет эффективно обрабатывать эти запросы в 
многопользовательской среде, с использованием механизма мультипроцессорности для обеспечения быстрой реакции на 
поступающие данные.
Создайте класс WarehouseManager - менеджера склада, который будет обладать следующими свойствами:
Атрибут data - словарь, где ключ - название продукта, а значение - его кол-во. (изначально пустой)
Метод process_request - реализует запрос (действие с товаром), принимая request - кортеж.
Есть 2 действия: receipt - получение, shipment - отгрузка.
а) В случае получения данные должны поступить в data (добавить пару, если её не было и изменить значение ключа,
 если позиция уже была в словаре)
б) В случае отгрузки данные товара должны уменьшаться (если товар есть в data и если товара больше чем 0).
3.Метод run - принимает запросы и создаёт для каждого свой параллельный процесс, запускает его(start) и 
замораживает(join).
Пример работы:
# Создаем менеджера склада
manager = WarehouseManager()
# Множество запросов на изменение данных о складских запасах
requests = [
  ("product1", "receipt", 100),
  ("product2", "receipt", 150),
  ("product1", "shipment", 30),
  ("product3", "receipt", 200),
  ("product2", "shipment", 50)
]
# Запускаем обработку запросов
manager.run(requests)
# Выводим обновленные данные о складских запасах
print(manager.data)
Вывод на консоль:
{"product1": 70, "product2": 100, "product3": 200}'''
#######################################################################################################################

from multiprocessing import Process, Manager

class WarehouseManager:
    """
    Класс для управления данными о движении товаров на складе.
    """
    def __init__(self):
        # Используем Manager для создания безопасного общего словаря между процессами.
        """ Менеджер из модуля multiprocessing создаёт объекты (например, словари, списки),
        которые можно безопасно использовать в нескольких процессах.
        Менеджер работает через сервер (внутренний IPC — межпроцессное взаимодействие), чтобы обеспечивать
         синхронизацию и совместное использование данных.
        Плюсы:
            Простота: обеспечивает безопасность данных без дополнительных механизмов.
            Полезен, когда данные динамически меняются и их нужно разделять между процессами.
        Минусы:
            Низкая производительность из-за накладных расходов на межпроцессное взаимодействие.
            Подходит только для небольшого объёма данных."""
        manager = Manager()
        self.data = manager.dict()  # data хранит данные о количестве товаров на складе

    def process_request(self, request):
        """
        Обрабатывает запрос на обновление данных склада.
        Аргументы:
            request (tuple): Кортеж вида (название_продукта, действие, количество).
        """
        product, action, amount = request  # Распаковываем запрос

        if action == "receipt":  # Если запрос - получение товара
            # Увеличиваем количество товара или добавляем новую запись
            """
            Что делает self.data[product] = self.data.get(product, 0) + amount?
            self.data.get(product, 0) Проверяет, есть ли ключ product в словаре.
            Если ключ существует, возвращает его значение.
            Если ключ отсутствует, возвращает значение по умолчанию (в данном случае 0).
            + amount К значению товара добавляется количество из запроса (amount).
            self.data[product] = ... Записывает результат в словарь, обновляя количество товара.
            """
            self.data[product] = self.data.get(product, 0) + amount

        elif action == "shipment":  # Если запрос - отгрузка товара
            # Проверяем, есть ли товар в наличии и хватает ли его для отгрузки
            if product in self.data and self.data[product] > 0:
                # Уменьшаем количество товара, но не допускаем отрицательных значений
                self.data[product] = max(self.data[product] - amount, 0)

    def run(self, requests):
        """
        Обрабатывает список запросов, создавая отдельный процесс для каждого запроса.
        Аргументы:
            requests (list): Список кортежей запросов.
        """
        processes = []  # Список для хранения процессов
        for request in requests:
            # Создаем процесс для обработки запроса
            process = Process(target=self.process_request, args=(request,))
            processes.append(process)  # Добавляем процесс в список
            process.start()  # Запускаем процесс

        # Дожидаемся завершения всех процессов
        for process in processes:
            process.join()

# Пример использования класса WarehouseManager
if __name__ == "__main__":
    # Создаем экземпляр менеджера склада
    manager = WarehouseManager()

    # Задаем список запросов
    requests = [
        ("product1", "receipt", 100),
        ("product2", "receipt", 150),
        ("product1", "shipment", 30),
        ("product3", "receipt", 200),
        ("product2", "shipment", 50),
    ]

    # Обрабатываем запросы
    manager.run(requests)

    # Выводим обновленные данные о складе
    print(dict(manager.data))  # Преобразуем в обычный словарь для красивого вывода

####!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
'''Запускаем 20 раз и наблюдаем РАЗНЫЕ результаты!!!!
ИБО гонка!!! Состояние гонки (race condition) 
результат разный
{'product1': 70, 'product2': 100, 'product3': 200} или {'product1': 70, 'product2': 150, 'product3': 200} 
я думаю, что причина в прядке выполнения запросов
("product2", "receipt", 150) и ("product2", "shipment", 50), в зависимости от их очередности
  Короче прога гонит))) 
Если процесс ("product2", "receipt", 150) выполнится раньше, а затем ("product2", "shipment", 50), 
результат будет 150 - 50 = 100.
Если же ("product2", "shipment", 50) начнёт обрабатываться раньше, когда product2 ещё не добавлен в data, 
то этот запрос может быть проигнорирован (так как product2 ещё не существует), и результат останется 
равным 150 после второго запроса.'''
##########################################################################################################
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
'''Чернышевский рулит:
Что делать?
берем книжку и читаем module_11_1_old_variant_2
без спойлеров, но будет интересно...'''
###########################################################################################################
"""
⠄⠄⠄⢠⣄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⢀⡀
⠄⠄⠄⢸⣿⣝⠦⣀⠄⢀⣀⣀⠄⠄⠄⣠⣾⣿⡇
⠄⠄⠄⢸⣿⣿⣿⣾⠿⢯⣿⣿⣯⣷⣾⣾⣿⣿
⠄⢀⡴⣺⣿⣿⡿⢛⣽⣿⣶⣶⡺⣿⣿⣿⣿⡇
⢀⣾⣾⣿⣿⣿⣿⢋⡙⣿⣿⣿⡟⣿⣿⣿⣿⡇
⢸⣿⣿⣿⣿⣿⣧⣈⣡⣿⣿⣿⣧⣙⣛⠿⣿⣿⣀
⢸⣿⣿⣿⠋⠄⠄⠄⢸⣿⣿⣿⣿⡄⠄⠄⢀⣿⣿⣯⣥⣖⣲⠦⣄⣀
⢸⣿⣿⣿⣷⡦⢤⡀⢸⣿⣿⣿⣿⣷⣄⣴⣿⣿⣿⣿⣿⣿⣿⣿⣶⣯⣟⣦⡀
⢸⣿⣿⣿⣿⡇⠄⢹⣯⣶⣿⣿⣿⣿⣿⣹⣿⣿⠄⠄⠉⠉⠛⠻⣿⣿⣿⣿⣿⡄
⠄⣿⣿⣿⣿⣧⣰⣾⠿⠿⠛⢿⠟⠛⠛⢹⣿⣿⠄⠄⠄⠄⠄⣠⣾⣿⣿⣿⡿⠁
⠄⣿⣿⣿⣿⣿⠶⣿⠄⠄⠄⣨⣀⣀⠄⢘⣿⣿⠄⠄⣠⣴⣿⣿⣿⣿⡿⠟⠁
⠄⢿⣿⣿⣿⣿⡖⢻⠖⠒⢻⣤⢾⡏⠉⠙⣿⣿⣶⣿⣿⣿⣿⠿⠋⠁
⠄⢸⣿⣿⣿⣿⣧⠈⠄⠄⠄⠙⠄⠄⠄⠄⣿⣿⣿⣿⣿⡏
⠄⢸⣿⣿⣿⣿⣿⣆⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⣿⣿⡟
⠄⢸⣿⣿⣿⠉⢿⣿⣄⠄⠄⠄⠄⠄⠄⠄⢹⣿⣿⡉
⠄⠈⣿⣿⣿⣧⠈⢿⣿⣦⡀⠄⠄⠄⠄⠄⠈⣿⣿⣿⡀
⠄⠄⢿⣿⣿⣿⣦⠄⠙⢿⣿⣦⡀⠄⠄⠄⠄⢸⣿⣿⣇
⠄⠄⠘⣿⣿⣿⣿⣧⠄⠄⠻⣿⣿⣦⡀⠄⢀⣼⣿⣿⣿⣵⡀
⠄⠄⠄⠘⢿⣿⣿⣿⠄⠄⠄⠘⣿⣿⣿⡏⠉⣿⣿⣿⣿⣿⣿⣆
⠄⠄⠄⠄⠄⠻⣿⢿⢣⠄⠄⠄⢹⣿⣿⡆⠄⣿⣿⣿⣿⣿⣿⣿⡄
⠄⠄⠄⠄⠄⠄⠘⠈⠄⠄⠄⠄⠘⣿⣿⣷⣤⣿⣿⣿⣷⣽⣿⣿⡇
⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠻⣿⣿⣿⣿⣿⣿⣿⣿⡇⠉⠁
⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠈⠁⣸⣿⣿⣿⣿⣿⣿⣄
⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣀⣤⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⡆
⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠚⠟⠛⠛⠛⠛⠛⠙⠻⣿⣿⡿⠃
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⡏⠉⠉⠉⠉⠉⠉⠉⠉⢹⡏⠉⠉⠉⣿⣿⣿⣿⣿⡏⠉⠉⣿⣿⣿
⣿⣿⣿⣿⣿⣇⠄⠄⠄⠄⠄⠄⠄⠄⣸⡇⠄⠄⠄⣿⣿⣿⣿⣿⡇⠄⠄⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⠄⠄⠄⠄⣿⣿⣿⡇⠄⠄⠄⣿⣿⣿⣿⣿⡇⠄⠄⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⠄⠄⠄⠄⣿⣿⣿⡇⠄⠄⠄⣿⣿⣿⣿⣿⡇⠄⠄⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⠄⠄⠄⠄⣿⣿⣿⡇⠄⠄⠄⠙⢿⣿⣿⣿⡇⠄⠄⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⠄⠄⠄⠄⣿⣿⣿⡇⠄⠄⠄⠄⠄⠙⢿⣿⡇⠄⠄⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⡆⠄⠄⠄⣿⣿⣿⡇⠄⠄⠄⡀⠄⠄⠈⣿⡇⠄⠄⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⡇⠄⠄⠄⣿⣿⣿⡇⠄⠄⠄⣿⡄⠄⠄⣿⡇⠄⠄⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⡇⠄⠄⠄⢻⣿⣿⡇⠄⠄⠄⡿⠄⠄⠄⣿⡇⠄⠄⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⡇⠄⠄⠄⢸⣿⣿⡇⠄⠄⠄⠄⠄⠄⢠⣿⡇⠄⠄⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⡇⠄⠄⠄⢸⣿⣿⡇⠄⠄⠄⠄⣀⣴⣿⣿⡇⠄⠄⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣶⣶⣾⣿⣿⣷⣶⣶⣾⣿⣿⣿⣿⣿⣷⣶⣶⣿⣿⣿
⡟⠉⠉⠛⢿⣿⠋⢹⣿⣯⠉⢿⠉⢹⡟⠉⠉⢻⣿⣿⠉⢿⣿⡏⠉⣿⠋⢹⣿⣿
⣿⣿⣿⠄⢸⣿⠄⠈⣿⣿⡄⠄⠄⣿⠇⢰⣧⠄⣿⡇⠄⢸⣿⡇⠄⡏⠄⢸⣿⣿
⣿⣏⠄⠠⣾⡇⠄⠄⣿⣿⣷⠄⢠⣿⠄⢸⣿⠄⣿⡇⠄⠈⣿⡇⠄⠄⠄⢸⣿⣿
⣿⣿⣷⠄⢸⠇⢠⠄⢸⣿⡏⠄⠈⣿⡀⢸⣿⠄⣿⠃⢰⠄⣿⡇⠄⢀⡇⢸⣿⣿
⠟⠻⠟⠄⣸⠄⢀⠄⢸⡟⠄⣴⠄⢹⣇⠘⠋⢠⡿⠄⠸⠄⠸⡇⠄⣸⡇⢸⣿⣿
⣶⣶⣶⣶⣿⣤⣾⣧⣼⣷⣶⣿⣧⣴⣿⣶⣶⣿⣷⣶⣶⣶⣶⣷⣶⣿⣧⣼⣧⣼
⡿⠿⠿⢿⣿⠿⠿⣿⣿⠿⣿⣿⠛⣿⠟⣿⣿⠟⠻⡟⠛⠟⠛⠛⠛⣿⠟⠛⠻⣿
⡇⠄⣶⣾⠏⢀⣤⣿⣿⠄⢸⣿⠄⡏⠄⢸⣿⠄⠄⡇⠄⣶⡆⠄⣶⡇⠄⣦⠄⢸
⣿⠄⠿⢿⠄⢸⣿⣿⡟⠄⠸⣿⠄⠄⠄⢸⣿⠄⠄⡇⠄⣿⡇⠄⣿⡇⠄⣿⠄⢸
⣿⠄⣶⣾⠄⢸⣿⣿⡇⢀⠄⣿⠄⢀⡀⢸⣿⠄⠄⡇⠄⣿⡇⠄⣿⡇⠄⣿⠄⢸
⣿⠄⠻⢿⡇⠘⠛⢻⠄⣾⠄⣿⠄⣸⡇⢸⣿⣄⠄⠁⠄⣿⡇⠄⣿⡇⠄⣿⠄⢸
⣿⣶⣶⣾⣿⣶⣶⣿⣶⣿⣶⣾⣶⣿⣷⣾⣿⣿⣿⡇⠄⣿⡇⠄⣿⣇⠄⠁⢀⣼
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
"""


