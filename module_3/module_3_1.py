# Домашняя работа по уроку "Пространство имён"

# Задача "Счётчик вызовов":
# Порой необходимо отслеживать, сколько раз вызывалась та или иная функция. К сожалению,
# в Python не предусмотрен подсчёт вызовов автоматически.
# Давайте реализуем данную фишку самостоятельно!
#
# Вам необходимо написать 3 функции:
# Функция count_calls подсчитывающая вызовы остальных функций.
# Функция string_info принимает аргумент - строку и возвращает кортеж из: длины этой строки,
# строку в верхнем регистре, строку в нижнем регистре.
# Функция is_contains принимает два аргумента: строку и список, и возвращает True, если строка
# находится в этом списке, False - если отсутствует.
# Регистром строки при проверке пренебречь: UrbaN ~ URBAN.

# Пункты задачи:
# Создать переменную calls = 0 вне функций.
# Создать функцию count_calls и изменять в ней значение переменной calls. Эта функция должна вызываться
# в остальных двух функциях.
# Создать функцию string_info с параметром string и реализовать логику работы по описанию.
# Создать функцию is_contains с двумя параметрами string и list_to_search, реализовать логику
# работы по описанию.
# Вызвать соответствующие функции string_info и is_contains произвольное кол-во раз с произвольными данными.
# Вывести значение переменной calls на экран(в консоль).
#
# Пример результата выполнения программы:
# Пример выполняемого кода:
# print(string_info('Capybara'))
# print(string_info('Armageddon'))
# print(is_contains('Urban', ['ban', 'BaNaN', 'urBAN'])) # Urban ~ urBAN
# print(is_contains('cycle', ['recycling', 'cyclic'])) # No matches
# print(calls)
#
# Вывод на консоль:
# (8, 'CAPYBARA', 'capybara')
# (10, 'ARMAGEDDON', 'armageddon')
# True
# False
# 4
#
# Примечания:
# Для использования глобальной переменной внутри функции используйте оператор global.
# Для функции is_contains лучше привести и искомую строку и все строки в списке в один регистр.
####################################################################################################

calls = 0     # Счетчик вызовов функции count_calls другими функциями (нужен по условиям задания).
#calls_func_list_global = {} # Словарь имен всех вызываемых функций со счетчиком.
                             # Сначала создавал вне функции, потом решил усовершенствовать для универсальности.
my_list = [
    'ДерЕво',
    'Белое СОЛНЦЕ в пустЫНЕ',
    'PyCharM'
]

# ФУНКЦИЯ СЧЕТЧИКА ВЫЗОВОВ ФУНКЦИЙ В ПРОГРАММЕ.
# Объявляет глобальную переменную (ранее специально не определенную в основном коде) calls_func_list_global,
# в которой записываются имена всех запускаемых в программе функций (при условии вызова счетчика в коде
# этих функций) и количество их запусков. Учитываются и вызовы самой функции счетчика))).
def count_calls(name_funk = 'count_calls'):
    global calls, calls_func_list_global  # При первом запуске calls_func_list_global не определена, что вызывает
# значительный гемморой(((. Пришлось в следующем блоке делать КоСтЫлЬ TRY и except NameError, для её ОБЪЯВЛЕНИЯ и
# задания первоначального пустого значения словаря. При повторных запусках пустая потеря ресурсов. Зато решен
# вопрос некой автономности и универсальности за счет создания словаря для счетчика БЕЗ ПРЕДВАРИТЕЛЬНОГО
# объявления ВНЕ функции.
    try:
        len(calls_func_list_global)
    except NameError:
        calls_func_list_global = {}

    if name_funk != 'count_calls':                 # Проверяем условие запуска счетчика внешней функцией.
        calls += 1
        try:       # Словарь счетчика уже определен, НО ключи и значения могут отсутствовать. (опять обработка ошибки).
            calls_func_list_global[name_funk] += 1
        except KeyError:
            calls_func_list_global[name_funk] = 1

    try:    # Собственный Счетчик вызовов. С обработкой ошибки при первой записи на отсутствие ключа.
        calls_func_list_global['count_calls'] += 1
    except KeyError:
        calls_func_list_global['count_calls'] = 1

    #print(count_calls.__name__) #Вариант получения собственного имени функции.

# Функция преобразования строки и создания кортежа.
def string_info(string = ''):
    count_calls(string_info.__name__) # ВЫЗЫВАЕМ ФУНКЦИЮ СЧЕТЧИКА. Используем count_calls.__name__ для передачи имени

    string = input('Введите строку для обработки: ')

    string_len = len(string)
    string_up = string.upper()
    string_low = string.lower()

    my_string_info = (string_len, string_up, string_low)  # Объявляем КОРТЕЖ из результатов анализа строки

    return my_string_info

# Функция поиска строки в списке.
def is_contains(string = '', list_to_search = [' ']):
    count_calls(is_contains.__name__)  # ВЫЗЫВАЕМ ФУНКЦИЮ СЧЕТЧИКА. Используем count_calls.__name__ для передачи имени

    for search_text in list_to_search:
        if string.lower() in search_text.lower():
            result_searching = True
            break
        else:
            result_searching = False

    return result_searching


#Основной блок
count_calls() # Вызов функции для проверки счетчика собственных вызовов вне других функций.

print(string_info())
print(string_info())

# Надо разобраться с передачей аргументов в функцию
print(is_contains(string = input(f'Введите строку для поиска в списке {my_list}: '), list_to_search = my_list))


print(calls , calls_func_list_global)
print(f'count calls: {calls}')
print('наименование и количество вызовов функций:')
[print(x) for x in calls_func_list_global.items()]

#print(**calls_func_list_global, sep = "\n") #НЕ РАБОТАЕТ????!!!!!!!
