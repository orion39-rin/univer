# Домашнее задание по уроку "Распаковка позиционных параметров"

# Задача "Распаковка":
# 1.Функция с параметрами по умолчанию:
# Создайте функцию print_params(a = 1, b = 'строка', c = True), которая принимает три параметра
# со значениями по умолчанию (например сейчас это: 1, 'строка', True).
# Функция должна выводить эти параметры.
# Вызовите функцию print_params с разным количеством аргументов, включая вызов без аргументов.
# Проверьте, работают ли вызовы print_params(b = 25) print_params(c = [1,2,3])

# 2.Распаковка параметров:
# Создайте список values_list с тремя элементами разных типов.
# Создайте словарь values_dict с тремя ключами, соответствующими параметрам функции print_params,
# и значениями разных типов.
# Передайте values_list и values_dict в функцию print_params, используя распаковку параметров
# (* для списка и ** для словаря).

# 3.Распаковка + отдельные параметры:
# Создайте список values_list_2 с двумя элементами разных типов
# Проверьте, работает ли print_params(*values_list_2, 42)

# Пример результата выполнения программы:
# Исходный код:
# values_list_2 = [54.32, 'Строка' ]
# print_params(*values_list_2, 42)
#
# Вывод на консоль:
# 54.32 'Строка' 42
#
# Примечания:
# Использование параметров по умолчанию позволяет функциям быть гибкими и удобными в использовании.
# Распаковка параметров из списка и словаря позволяет передавать группы значений в функцию, что упрощает
# работу с данными.

###########################################################################################################
# Важно!
# Не передавайте списки задавая по умолчанию пустой список или другой изменяемый тип данных!
# В таком случае, если этот список будет изменён внутри функции, то на следующий вызов функции он останется
# в том же состоянии.
#
# def a(my_list = [])) – это приводит к ошибкам!!!!!!!!!!!!!!!!!
#
# Можно передавать вот так(список создаётся локально, мы не влияем на его изменение вне функции)
# def append_to_list(item, list_my=None):
#   if list_my is None:
#    list_my = []
#   list_my.append(item)
# print(list_my)
###############################################################################################################
# СМОТРИ ПОЯСНЕНИЯ В КОНЦЕ КОДА!!!!
########################################################################################################

def print_params(a=1, b='строка', c=True):
    print(f' a = {a} \n b = {b} \n c = {c}')
    print('------------------ \n')

def print_kwargs(**kwargs):
    print('kwargs =', kwargs)
    for key, value in kwargs.items():
        print(key, '=', value)

# Вызов функции с параметрами по умолчанию.
print_params()
# Вызов функции с указанием одного именованного параметра.
print_params(b = 25)
print_params(c = [1,2,3])

# Список и словарь парамеров.
values_list =['emal', [192, 168, 0, 1], True]
values_dict = {'a': 'sender', 'b': [10, 10, 10, 1], 'c': False}

# Вызов функции с распаковкой.
print_params(*values_list)
print_params(**values_dict)


# Пример для kwargs с распаковкой.!!!!!!!!!
print_kwargs(**values_dict)

# Пример для kwargs с УПАКОВКОЙ.!!!!!!!!!!!
print_kwargs(x=2, y=[192, 168, 0, 1],
             key_1='Значение Ключа key_1',
             key_2='Значение Ключа key_2',
             z11=True,
             variable="КЛЮЧОМ **KWARGS в передаваемых аргументах должна быть ПЕРЕМЕННАЯ!!!!!!!!!!"
)

# Распаковка + отдельные параметры.
# Шпора:
print('\n', '   Шпора: ', '\n' ,
      "   def example_kwargs(arg_1, arg_2, *args, kw_1='domain', kw_2='address_ip', **kwargs):"
)

values_list_2 = [54.32, 'Строка' ]
print_params(*values_list_2, 42) # PyCharm указывает, что а=42, НО на самом деле 42 передается С (с=42)!!!!

##############################################################################################################
# Пояснения к примечанию. Учитываем локальные и глобальные переменные!
list_my = 1 # Глобальная переменная - не изменяется после вызова функции (если ее не объявить в ней как GLOBAL)
            # ЕСЛИ использовать прямое объявление в именованных параметрах def append_to_list(item, list_my=[])
            # ЗНАЧЕНИЕ list_my сохранится в локальной памяти функции как значение по умолчанию!!!!
            # то есть, при следующем вызове функции БЕЗ ЯВНОГО УКАЗАНИЯ значения list_my будет использоваться
            # В_С_Е результат(ы) ПРЕДЫДУЩЕГО(ИХ) вызова(ов)!!!

def append_to_list(item, list_my=None):
    if list_my is None:
        list_my = []
    list_my.append(item)
    print(list_my)
append_to_list([1, 'apple'])
append_to_list("rotty", [39])
append_to_list([1, 'apple'])
append_to_list("rotty", [39])
append_to_list([1, 'apple'])
print(list_my) # Глобальное значение не меняется после всех вызовов append_to_list

def append_to_list_test(item, list_my=[]):
    #if list_my is None:
    #    list_my = []
    list_my.append(item)
    print(list_my)
append_to_list_test([1, 'apple'])
append_to_list_test("rotty", [39]) # значение предыдущих вызовов не учитываются
append_to_list_test([1, 'apple'])
append_to_list_test("rotty", [39]) # значение предыдущих вызовов не учитываются
append_to_list_test([1, 'apple']) # УЧИТЫВАЮТСЯ ДВА!!!! предыдущих вызова без явного указания значения list_my
print(list_my) # Глобальное значение не меняется после всех вызовов append_to_list