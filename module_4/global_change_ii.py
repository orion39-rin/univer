from pprint import pprint # Импортируем функцию для прикольной печати и демонстрации Built-in.

# Глобальные переменные
my_global_dict = {1: 39, 2: True}
my_global_list = [1, False]
my_global_set = {1, 2}


def help_legb():
    """
    Выводит объяснение принципа LEGB (Local, Enclosing, Global, Built-in),
    который описывает порядок поиска переменных в разных областях видимости.
    """
    # Возможно здесь создать запрос о продолжении печати справки, так задумка на будущее...

    explanation = """
    Правило LEGB — это способ, которым Python определяет область видимости переменных.
    Название LEGB является аббревиатурой, которая расшифровывается следующим образом:

    **L (Local)**: Локальная область видимости. Переменные, определенные внутри функции.
    **E (Enclosing)**: Область видимости внешней функции. Для вложенных функций.
    **G (Global)**: Глобальная область видимости. Переменные, определенные вне всех функций.
    **B (Built-in)**: Встроенная область видимости. Переменные, функции и классы по умолчанию.

    Порядок поиска переменных:
    1. Локальная область (L).
    2. Область внешней функции (E).
    3. Глобальная область (G).
    4. Встроенная область (B).
    """
    print(explanation)


def change_global_value(lst_f: list, d_f: dict, set_f: set):
    """
    Демонстрирует изменения глобальных объектов (списки, словари, множества),
    переданных как аргументы.
    """
    # Добавление элементов в переданные структуры данных
    lst_f.append("добавлено в локальной области внутри функции")
    lst_f.append("без объявления my_global_list в GLOBAL")

    d_f['new_local_key1'] = "изменяемые объекты передаются в функцию"
    d_f['new_local_key2'] = "в виде ссылки на глобальный исходный объект"

    set_f.add("множество тоже передается в функцию")
    set_f.add("как ссылка")

    print('Локальные изменения в функции:')
    pprint({'lst_f': lst_f, 'd_f': d_f, 'set_f': set_f})
    # или
    print('Локальные изменения в функции:', '\n lst_f:', lst_f, '\n d_f: ', d_f, '\n set_f', set_f, '\n')

    def inner_sub_change_1():
        """Функция для демонстрации работы с вложенными областями видимости."""

        nonlocal set_f, d_f, lst_f # Обращаемся напрямую к **E (Enclosing): Области видимости внешней функции.

        # Пример работы с внешними (Enclosing) переменными
        lst_f.append("изменено во вложенной функции (Enclosing)")
        d_f['inner_key'] = 'добавлен во вложенной функции'
        set_f.add("вложенная функция тоже изменила множество")

        # Работа с копией списка, чтобы не менять глобальный список
        local_lst_copy = lst_f.copy()  # Создаём копию списка для работы с ним
        local_lst_copy.append("изменения только в копии списка")

        pprint({'inner_lst_f': lst_f, 'local_lst_copy': local_lst_copy, 'inner_d_f': d_f, 'inner_set_f': set_f})

    inner_sub_change_1() # Вызов вложенной функции БЕЗ передачи аргументов



    def inner_sub_change_2():
        """Демонстрация применения ... и pass для заглушек в Python"""
        # Заглушка с использованием Ellipsis
        ...

        # Заглушка с использованием pass
        pass

        # Объяснение различий между ... и pass
        print("""
        В Python существуют два основных способа создания заглушек, 
        когда нужно оставить часть кода без реализации, но сохранить синтаксическую корректность:

        - ... (Ellipsis): Специальный объект, используемый как заглушка, 
          когда реализация функции или блока ещё не добавлена, но синтаксис остаётся корректным.

        - pass: Инструкция для создания пустых блоков кода, где не требуется выполнение действий, 
          сохраняя синтаксическую правильность.
        """)

# Вызов справки
help_legb()

# Изменение глобальных объектов
change_global_value(my_global_list, my_global_dict, my_global_set)

# Проверка изменений глобальных объектов
print('После изменений в глобальных объектах:')
print(f'my_global_list: {my_global_list}')
print(f'my_global_dict: {my_global_dict}')
print(f'my_global_set: {my_global_set}')


# Определяем несколько глобальных переменных
p = 'Python'
q = 'Code'

# Получаем только существующие переменные
keys_to_fetch = ['p', 'q', 'r']  # Обратите внимание, что 'r' не существует
selected_values = {key: globals().get(key) for key in keys_to_fetch if key in globals()}

print(selected_values)  # {'p': 'Python', 'q': 'Code'}


# Определим несколько глобальных переменных
x = 10
y = 20
z = 30

# Получаем значения по именам
keys = ['x', 'y', 'z']  # Список имен переменных, которые нужны
values = [globals().get(key) for key in keys]  # Список значений

print(values)  # [10, 20, 30]


# Определим несколько глобальных переменных
a = 100
b = 200
c = 300

# Словарь с нужными значениями из globals
selected_globals = {key: globals()[key] for key in ['a', 'b', 'c']}

print(selected_globals)  # {'a': 100, 'b': 200, 'c': 300}


# Определяем несколько глобальных переменных
p = 'Python'
q = 'Code'

# Получаем только существующие переменные
keys_to_fetch = ['p', 'q', 'r']  # Обратите внимание, что 'r' не существует
selected_values = {key: globals().get(key) for key in keys_to_fetch if key in globals()}

print(selected_values)  # {'p': 'Python', 'q': 'Code'}
